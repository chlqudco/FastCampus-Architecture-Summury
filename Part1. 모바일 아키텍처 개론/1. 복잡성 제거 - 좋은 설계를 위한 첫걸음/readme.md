- 문제점
	- 어떤 설계가 좋은지, 앱에 맞는 좋은 아키텍쳐가 뭔지 모름
	- 또한 아키텍처를 고른 판단 근거를 잘 설명하지 못함
	- 아키텍처에 대한 기본 지식을 배워보자

- 복잡성 제거
	- 어찌됐든 설계가 제일 중요하다? 뭔소리야

- 좋은 아키텍처란?
	- 앱이 풀고 싶어하는 문제에 잘 어울리는 설계
		- 코드 구조가 시스템이 어떻게 동작하는지 잘 보여줘야 함
		- 요구사항이 변함에 따라 아키텍쳐도 변화에 민감해야 함
	- 이런게 쉬워야 한다
		- 코드 이해
		- 그 코드가 왜 이렇게 되었어야 하는지 이유
		- 유지보수 
		- 테스트, 테스트 하기 어려운 설계는 잘못된 설계일 확률이 높다
	- 더 올바른 경향이 있다
		- 뭔소리
	
- 좋은 아키텍처의 방해물
	- 복잡성
		- 시스템을 이해, 수정하기 어렵게 만드는 모든것
		- 코드가 긴게 복잡성이 높은게 아님
	
- 나쁜 복잡성의 징후
	- 작은 변경에도 많은 곳의 코드를 고쳐야 함
	- 작은 변경에도 많은 선수 지식이 필요하다
	- 작은 변경에도 알 수 없는 결과가 많이 생긴다

- 복잡성을 일으키는 세가지 요인
	- 의존성
		- 모듈(클래스)이 독립적이지 못하고 의존성이 강하면 코드 이해가 어려움
		- 물론 없앨 순 없지만 줄여야 함
	- 불명확함
		- 중요한 정보가 불명확함
		- 메소드의 하는 일과 입력, 반환 등 이해하기가 힘듬
	- 전술적 프로그래밍
		- 빨리 완성하는데 초점을 두기 때문
		- 반대말은 전략적 프로그래밍

- 복잡성을 낮추는 법
	- 불필요한 정보는 감춘다 (추상화)
		- 깊은 모듈이 필요함
		- 인터페이스는 범용으로
		- 정보를 잘 은닉해야 함 (캡슐화)
	- 깔끔한 추상화
		- 복잡성을 하위레벨로 끌어내리기
		- 추상화 사이의 경꼐 찾기

- 깊은 모듈이란?
	- 많은 작업이 일어나는 일을 간단히 호출할 수 있다
	- 사용자는 맨 위의 수면?만 알면 사용할 수 있다
	- 예를 들어 파일 오픈 아래의 과정을 아무것도 몰라도 사용자는 파일오픈 메소드만 쓰면 사용가능
	
- 범용 인터페이스란?
	- 넓게 사용가능한 인터페이스
	- 재사용성이 높다
	- 현재 요구사항을 만족하는 가장 심플한 인터페이스가 무엇인지 고민해봐야 함
	- 이 메소드가 얼마나 많은 상황에서 사용될까 하는 물음을 던져봐라
		- 한곳 이라면 잘못된거임

- 정보 은닉이란?
	- 불필요한 정보를 감춰라, 불필요한 public과 변수가 없는지 확인
	- 사용자가 일반적인 작업을 위해 필요없는 로직까지 읽어야 하는 과정이 잘못된거임

- 복잡성을 아래로 끌어내리기
	- 심플한 인터페이스는 심플한 구현보다 낫다
	- 기존에 있는 기능과 밀접하게 연관된 경우
	- 앱의 여러부분들을 더 단순하게 만들어 주는 경우
	- 클래스의 인터페이스를 단순하게 만들여 주는 경우
	- 위 3개의 경우 복잡성을 더 끌어내릴 수 있다
	- ex) 버퍼를 읽는 예시처럼 버퍼를 잘 몰라도 사용자가 쉽게 사용할 수 있도록 설계하라

- 추상화 사이의 경계 찾기
	- 이럴때는 합치자!
		- 정보가 공유되는 경우
		- 함께 있는 것이 인터페이스를 더 단순하게 하는 경우
		- 코드 중복이 없어지는 경우
	- 이럴때는 나누자!
		- 특정 목적의 API가 범용 클래스 안에 있는 경우
		- 다른 종류의 범용 매커니즘이 함께 있는 경우

- 재사용성..
	- 단순히 코드 중복을 기계적으로 줄이는 것이 목적이 아님
	- 인터페이스의 사용성을 더 낫게 해주는 것이 목적?
