- 아마 이거 들으려고 강의 결제 한거 아닌가?

- 시작하기 전에 2가지만 말하자
	- MVVM이라고 말했지만 공통적으로 다른 패턴에도 동일하게 겹치는 내용이 많다.
	- 구글의 MVVM은 계속 보강되고 있다. 앞으로도 당연히. 

- 근저의 철학에 대해 얘기해보자
	- 단방향 데이터 흐름
		- 뷰를 완벽하게 수동적으로 만들기 위한 구조
		- State Holder와 View를 생각해보자
		- 홀더는 상태변경을 뷰에게 알려준다. 그러나 존재하지 않는 방향.
		- 홀더는 사실 뷰를 모른다. 이벤트만 주는 형태.
		- 정리해서 상위 객체는 하위 객체로부터 상태를 읽을 수 없어야 한다. 존재조차 몰라야 한다.
		- 뷰는 자신이 받은 사용자 입력을 전달만 할 뿐 직접적으로 결과를 받지 않음. 대신 이벤트 형태로 상태 변경을 통보 받는다

- 뷰모델이 되면서 어떤게 달라짐?
	- 데이터 바인딩이 추가됨에 따라 이름이 뷰모델이 됨 
		- 이벤트를 뷰로 바로 적용할 수 있는 매커니즘 제공
	- 뷰모델은 그 자체로 독립적인 시스템임
		- 그저 결과를 이벤트로 보낼 뿐, 뷰의 존재를 모름
		- 테스트가 쉬워짐

- 데이터 바인딩이 왜 필요힘?
	- 없다면 순환 이벤트 흐름이 생길 수 있음
	- 뷰 이벤트 발생 -> 뷰모델이 처리 후 이벤트로 알려줌 -> 뷰가 다시 이를 받음
		- 잘못 된건 아닌데 부자연스럽고 이상한 느낌
	- 뷰 모델은 뷰가 바라보는 싱글 소스여야 함
		- 데이터나 상태를 갖고 있는데 이는 뷰가 갖고 있으면 안됨
	- 데이터 바인딩이 없다고 MVVM이 아닌건 아님

- mVVM의 단점
	- 학습곡선
		- 이벤트를 기본적으로 반응형(Reactive)로 받아야 하므로, 이 개념에 대한 숙지가 필요, 콜백으로 받는건 말이 안됨
		- 코루틴 라이브러리 학습이 필요
	- 모든 로직을 뷰모델에 의존함으로써 Fat ViewModel이 될 위험성
		- 큰 크기의 모델을 피하기 어려움
	- 순환 이벤트 흐름을 완전히 막기 어려움
		- 리스트 내의 처리나 내비게이션의 화면이동
		- 방법 : State 홀더를 하나 더 만들자

- 의문점 : 왜 구글은 배우기도 어렵고 코루틴 안쓰면 제대로 구현도 안되는 뷰모델을 AAC(안드로이드 아키텍처 컴포넌트)에서 지원할까?
	- 기존 액티비티/프래그먼트의 형태를 깨뜨리지 않으면서 재사용성/생산성이 높은 아키텍처를 구현 가능하기 때문
	- 안드로이드의 생명주기 처리에 가장 잘 어울리는 구조
		- 뷰 모델안의 상태나 내용을 살아남게 할 수 있음
		- 생명주기 내에서 설정 변경과 프로세스 종료가 일어나도 뮤모델의 내용이 보존되는 구조를 제공함
		- SavedStateHandle
		- 또한 코루틴이 뷰모델의 생명주기 내에서 동작될 수 있도록 하는 환경을 제공함

- Fat ViewModel의 해결책
	- MVC처럼 뷰를 최대한 분리하자
	- 분리한뒤 각 뷰마다 뷰모델을 따로 만들자
	- 액티비티가 클땐 여러개의 뷰모델을 만들 수 밖에 없다 
		- 특정 화면 전체를 담당하는 뷰모델이 더 필요할 수도 있음

- 안티패턴
	- 상태가 유실 될 수 있는 공급자(Provider)를 통해 이벤트를 전달하는 것
		- 코루틴의 채널이나 Flowable등의 API는 데이터 전달을 완전히 보장하지 않음
	- UI 코드에서 액션까지 구현하는 것
		- UI는 현재 상태가 무엇이고 어떻게 반영할지만 결정해야 함
		- 비즈니스 로직이나 내비게이션 등은 뷰모델의 영역
	- 1회성 이벤트를 즉시 처리하지 않는 것
		- 특정 API는 낮은 우선순위로 실행될 수 있음. 사용하지 않는걸 추천
	
- 구글에서 제공하는 뷰모델은 뷰모델이 아니란 논란이 있다
	- 한 60프로는 맞는말 같다
	- 100퍼를 이루기 위해선 안티패턴이나 특정 사용법으로 줄여야 한다??

- 뷰모델 생성자에서 초기화 이상의 일을 하는 것은 좋지 않다
	- 사실 뷰모델 뿐만 아니라 모든 클래스의 얘기
		- 단일 책임 원칙 위반, 액터가 누구인지 잘 생각해보라.
		- 테스트 구현이 어려움
		- 상속시 자식에게 과한 정보의 습득을 요구
		- 사용자에게 필요없는 초기화를 수행하지 않게 만들 선택권 박탈
	- 생성자에서 하면 좋지 않은 일
		- 다른 객체의 생성
		- 정적 메소드 호출
		- 단순 대입 이상의 초기화 로직
		- 분기 로직
	- 해결법
		- lazy init을 이용하라
