- Hilt의 best practices

- 반드시 필요한 것만 provide 할 것
	- 의존성 주입은 정의된 모든 객체에 접근할 수 있는 강력함을 제공함.
	- 그 대신 모든 것이 전역적으로 보이게 되므로 주의가 필요함
	- 실제 구현 클래스는 노출하지 않는 것이 좋음
	- 가능한 한 Inject를 이용하라

- 복수의 바인딩에 @Inject 생성자를 사용하지 말 것
	- 다른 스코프에서 사용되는 복수의 바인딩이 있을 경우 인젝트 생성자를 쓰면 잘못된 바인딩이 생성될 수 있음

- @Named 대신 @Qualifier 사용
	- @Named는 설정이 간단하고 어디서든 재사용 가능하지만 semantic한 의미가 약함
		- 또 쉽게 실수 할 수 있고 리팩토링이 어렵고 컴파일 시에 실수가 파악되지 않음
	- @Qualifier가 위의 문제르 ㄹ모두 해결해줌

- Scope 사용에 주의하라
	- 스코프가 성능에 미치는 영향을 주의깊게 고려할 것

- 성능 팁
	- @Provides는 메소드 하나마다 내부적으로 팩토리 클래스를 생성함
		- 해결법 : 할 수 있는 한 @Binds를 사용하라
		- 해결법 : Provides는 static 메소드로 구현하라

	- @Module클래스가 코틀린이라면 provides 메소드만 있을 경우 object로 지정, bind메소드가 있을 경우 인터페이스로 지정

- 할 수 있는 한 @Inject 생성자는 internal로 지정하라
	- 대거 의존성이 생성자를 직접 이용해 잘못 생성되는 것을 방지

- 그 외
	- Hilt 모듈 클래스는 사람이 만든 클래스에서 직접 참조되면 안됨
	- Mock 대신 fake 혹은 실제 구현을 사용
		- Hilt 자체가 mock의 사용을 최소화하기 위해 만들어짐

- Hilt의 단점
	- 대거보다 더 opinionated 되어 있음
		- 앱 내의 의존성 구분이 컴포넌트가 Hilt가 제공하는 디폴트 트리 구조에 적합하지 않은 경우도 있음
	- 대거의 빌드 속도를 해결해주지 않음
		- 향후 KSP로 완전히 해결 가능
	- 여전히 자바 기반임
		- 젯팩 컴포즈에서는 추가적인 hack이 필요함
		- 귀찮은 널러빌리티 lint 경고
	- 대거의 heavy user 라면 일부 migration 과정에서 어려움을 겪을 수 있음

- Dagger, Hilt의 대안 : Koin
	- DSL 기반의 간단한 설정
	
- Koin 장점
	- 간단하게 바인딩/ 주입 구현
	- 필드 주입이 기본적으로 lazy임
	- 빠른 빌드 속도
	- 뷰모델도 단순함
	- 버젼업이 되면서 기능 추가도 많이 되고 있음
	
- Koin 단점
	- 컴파일 시 체크가 거의 없음
	- 실행시 오버헤드가 약간 있음
	- 어쨌든 Dagger / Hilt가 제공하는 방대한 기능의 부재

- 대안 2 : Anvil
	- Dagger 기반의 컴파일러 플러그인
	- Dagger와 완전히 동일한 기능 + 편리한 확장 제공
	- 유연한 플러그인
	- 어노테이션을 이용하지 않고 플러그인에서 직접 factory를 생성
		- 상당히 빠른 빌드 성능을 보여줌
