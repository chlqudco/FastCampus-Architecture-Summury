- MVI의 출발점
	- 모바일 앱의 가장 큰 난제중 하나는 복잡한 상태들을 어떻게 깔끔하고 유지보수성 높게 구현할 것인지이다
	- 이 발상을 바꿔서 앱 전체의 이벤트를 State Machine으로 처리한다면 어떨까?
	- 이러면 생명주기 처리로 골머리 앓을 일이 급격히 줄어듬
	- 또한 상태에 따라 다르게 동작하는 UI를 보다 직관적으로 관리 가능
	- 특정화면에서 수정된 내용이 다른곳에서 저절로 적용

- 그런데 직접 구현하다 보면 각 로직의 추상화를 어떻게 할지 고민됨
	- 상태 : enum 클래스 or sealed 클래스
	- 상태 천이 : 어떤 조건에서는 B로, 어쩔땐 C로 변경
	- 로직 수행 : 각 상태가 변경되었을 때 수행해야할 실제 로직
	- 위 세 요소를 만족하는 가장 범용적인 방법중 하나는 uni-directional한 pipeline 형태
	- 이것이 MVI 구조

- MVI? Redux? Flux?
	- MVI에서 I는 Intent, 의도라는 뜻. 어떤 의도나 목적을 가진 이벤트가 발생했을 때 이벤트의 처리에 집중하는 State Machine을 만들기 위한 패턴
		- 따라서 단방향의 이벤트 처리 파이프라인을 가지는 아키텍처를 부르는 넓은 의미의 용어
	- Flux는 페북에서 웹의 상태 처리를 직관적이고 깔끔하게 하기 위해 고안한 패턴.
		- 마찬가지로 단방향 파이프라인 루프를 통해 이벤트 처리
	- Redux는 MVI 패턴의 변형 구현체 중 가장 효율적이라고 알려진 구현체(웹 기준)
		- 굉장히 단순하게 구현. 초기에는 100줄짜리. 굉장히 젊은 개발자가 고안.

- Redux
	- Action
		- 뷰에서 이벤트가 일어날 때 호출
		- 상태를 변경하라는 명령만을 가짐
	- State
		- 상태의 데이터만을 가짐
	- Store
		- 상태의 저장소
		- 상태를 변경시키고, 통지하는 역할
	- Reducer
		- 뷰가 바로 사용할 수 있는 형태의 상태로 만들어줌

- Redux의 장점
	- 상태처리에서 어느정도 생명주기를 배제할 수 있다. 완전히라고 한적 없음.
	- 애매한 API 상황도 효과적으로 대처 가능
	- 상태의 정의, 저장, 처리 부분이 완벽히 나눠져 있기 때문에 수정/확장이 매우 편함
	- 유닛 테스트 작성이 극도로 편리함
	- 디버깅의 신세계

- Redux의 단점
	- 상당한 수준의 학습 비용이 소요
		- 기존에는 하나로 해도 될거 같은 일을 파이프라인을 통해..
	- 코드량이 증가함

- Redux가 성공한 이유
	- 이벤트 타입과 이벤트 핸들러를 같은 타입처럼 쓰는 자바스크립트의 특성을 활용
		- 상태를 뒤로 돌리는 등의 조작 가능
		- 각 상태의 처리 파이프라인에 대한 테스트 작성이 매우 쉬움
	- 그러나 정적 타입 언어에서는 누릴 수 없는 특성임
		- 이젠 망함?

- MVI 도입시 유의해야 할 점
	- 모바일 환경에서는 아직 이렇다할 합의가 없음
	- 이벤트의 취소는 어떻게 할 수 있는가?
		- 로직이 복잡하거나 미리 생각하지 않으면 나중에 매우 복잡해질 가능성이 큼
	- ? 그럼 MVVM에선 괜찮음?
		- 그렇답니다.

- 구조에는 정답이 없다
	- 제발 맹목적으로 믿지 마라
	- 자신이 처한 상황에서 최선의 구조가 무엇인지 생각해봐라

