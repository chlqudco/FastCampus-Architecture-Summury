- SOLID 원칙은 클린 아키텍쳐의 핵심이다
	- SOLID 원칙에 기반해 여러 사람들이 합의한 것이 모바일 클린 아키텍처이다
	- 따라서 SOLID 원칙을 잘 이해하는것은 필수이다
	- 그러나 명쾌하게 설명이 된 자료가 많지 않다

---

- SOLID 원칙이란

- 원칙의 대전제
	- SOLID 원칙은 기본적으로 중간 규모(클래스들이 모여있는 모듈구조..?)에 대한 원칙임
	- 다음과 같은 요구를 만족하도록 구조를 만드는 것이 목표이다
		- 유지보수성 : 변경에 유연해야 한다.
		- 가독성 : 이해하기 쉬워야 한다. 이름이나 배치들만 보고서 어떤일을 하는지 등을 이해해야 함
		- 낮은 결합도, 높은 응집도 : 하나의 모듈 안에서는 높은 응집도를 갖고 있어야 함. 어떤 기능이나 로직을 그 안에서 해결해야 함.  다른 모듈을 건들이지 않는걸 추천 	

- S : Single Responsibility Principle , 단일 책임 원칙
	- 응집도에 대한 기준을 말하는 원칙
	- 각 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
	- 하나의 모듈은 오직 하나의 액터에 대해서만 책임을 져야 한다
	- 하나의 클래스가 하나의 일을 해야 한다는 뜻이 아님
	- 책임이라고 하는 것은 업무나 일이 아닌 액터에 집중해라
	- ex) 이미지라는 클래스가 잘못된 이유는 세 개의 메소드가 서로 매우 다른 세 개의 액터를 책임지고 있기 때문이다
		- 로드 이미지는 다운로더 액터, 드로우는 뷰 액터 등등
		- 대부분은 이미지 작업에 대한 메소드를 하나로 묶어서 처리하려고 함
		- 그러나 주어가 무엇인지 확인하는 것이 중요하다. 주어는 액터이다. 이미지가 다운로드 하는것이 아님 다운로더가 이미지를 다운한다
		- 이미지가 주어(액터)인 것들을 모아라
	- 이미지 클래스가 잘못된 또다른 이유로는 감춰져 있는 액터가 있다.
	- 해결책 : 세 개의 클래스로 분리해라
		- 그러나 사용성이 떨어지는 것 같다는 단점이 생긴다
		- 사용성을 해결하기 위해 Facade 패턴이란게 있다
	
- O : Open-Closed Principle , 개방-폐쇄 원칙
	- 굉장히 오래된 역사를 갖고 있음
	- 객체 지향이 없었을 때 나온 개념임. 이때는 라이브러리에 대한 개념이였음
		- ex) 파일 IO의 버전업이 있을 때마다 사용자는 매번 코드를 바꿔야 했음	
		- 이러한 딥한? 부분을 최대한 속으로 감추고 사용자에겐 의미있는 것만 제공하자는 것이 개방폐쇄 원칙
	- 정리하면 소프트웨어 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다는 뜻
	- 열려 있다는건 데이터구조에 필드를 추가하거나 함수에 새로운 요소를 추가하는 것
		- 필드를 추가했다고 사용자가 사용하지 못하거나 코드를 고쳐야 되는걸 지양해야 함. 따라서 private 변수를 많이 씀
		- 함수도 마찬가지.
	- 닫혀 있다는 건 내부 코드를 변경해도 외부 모듈에 영향을 끼치면 안된다는 뜻
		- ex) 파일 오픈하는 방식이 전면적으로 바꼈다고 해도 사용하는 입장에서는 몰라야 한다는 뜻
	- 클래스 사이의 관계에서도 OCP는 중요하다.
		- 클래스는 서로 의존관계가 생기기 때문에 하위 계층에 의존하지 않도록 해야 한다.
		- ex) MVP의 프레젠터는 뷰에 의존하지 않지만 뷰는 프레젠터를 의존한다
		- ex) MVVM의 뷰모델은 뷰가 있던 말던 동작한다. 뷰는 뷰모델을 의존한다
	- 클래스의 모든 멤버변수는 왜 private나 protected여야 하나
		- 열려 있다는 건 사용자가 접근할 가능성이 있다는 뜻. 엉뚱한 일이 일어날 수 있음
		- 꼭 필요한것만 내줘야 한다. 인터페이스 설계의 중요성. 
	- 모듈 단위의 OCP는 의존 관계의 방향이 보호하려는 컴포넌트를 향하도록 그려져야 함
		- 높은 수준의 클래스가 하위 레벨의 변경으로부터 보호되기 위해

- L : Liskov Substitution Principle , 리스코프 치환 원칙
	- 대체 가능한 컴포넌트들을 이용해 시스템을 만들 수 있으려면, 이들의 서브타입들은 반드시 서로 치환 가능해야 한다.
	- ex) 자식들 중 어떤 것을 사용해도 동일한 역할을 함
		- 부모에서 정한 행위의 원칙을 자식에서 그대로 지키고 있기 때문에 행위 상속이라고도 부름
	- 위배하는 예시 : 직사각형과 정사각형 예시
		- 정사각형도 직사각형이니까 정사각형은 직사각형을 상속받아서 만들어야지! 하면 안됨
		- 직사각형을 정사각형 같은 곳에 사용되리라고 예상하지 못한 예외가 생길 수 있음. 넓이 구하는 문제
	- 자식은 부모가 갖고 있는 행위를 정확히 이해하고, 이 행위가 깨지지 않도록 할 의무가 있음
	- 상속보단 조합!
		- 상속보단 조합처럼 멤버변수로 갖고 있으면 영향이 덜 갈 수 있다?
	- JetPack 컴포즈의 탄생 배경이기도 함
		- 뷰 클래스는 굉장히 잘 설계해야 함. 지금은 수천줄에 다르고 있음
		- 정리를 어떻게 해야하징. 여러 문제가 생길 수 있는 기존의 문제를 완전히 끊기 위해 새로운 개념을 도입

- I : Interface Segregation Principle , 인터페이스 분리 원칙
	- 각 소프트웨어 모듈은 자신이 사용하지 않는 것에 의존하지 않아야 한다
	- 굉장히 당연한 얘기처럼 들린다
	- 자신이 사용하는 것에만 의존해야 한다는 뜻이다.
	- 인터페이스를 여러개 만들어도 상관 없..다?
	- 모듈 단위의 인터페이스 분리 원칙
		- 외부 모듈에 필요한 인터페이스만 노출해야 함

- D : Dependency Inversion Principle, 의존성 역전 원칙
	- 인터페이스 분리 원칙을 극명하게 드러내는 원칙
	- 보통 모듈 간에서만 적용되는 개념
	- 높은 수준의 코드는 낮은 수준의 세부사항 구현에 의존해서는 안되며 그 반대여야 한다 
	- 추상 팩토리 패턴을 이용하면 유용

- 이 원칙을 모바일에 적용해보자



