- MVP
	- 1990년대 초 IBM에서 최초로 구현
	- 2006년 마틴 파울러의 소개로 널리 알려짐
	- 안드로이드 초기부터 구전으로 전해져 왔던 아키텍처
	- 뷰는 비즈니스 로직에 관련된 부분을 관여하지 못하도록 분리함. 이를 Presenter에게 넘김
	
- 핵심 아이디어
	- 모든 UI관련 비즈니스 로직을 프레젠터에서 처리하도록 함
	- 뷰는 프레젠터의 요청에 따라 수동적으로 UI 처리를 함
	- 뷰는 반드시 인터페이스로만 프레젠터를 참조함
	- 의존성 역전의 원칙을 적용하면 뷰와 프레젠터 서로가 인터페이스로만 각자를 참조함
	- 여전히 콜백함수로 프레젠터가 커질 수 있음
	- 뷰의 변경이 있다고 해서 프레젠터의 코드를 바꿀 일이 없다는 장점

- Contract 패턴
	- 서로의 스펙만 알고 스펙대로만 부르면 된다.
	- 구체적인 구현은 알 필요가 없음

- 험블 오브젝트
	- 말그대로 갖고 있는게 아무것도 없는 객체
	- 뷰는 완전한 험블 오브젝트여야 함. 최대한 바보같이 움직여야 함.
	- 따라서 마틴 파울러는 프레젠터를 Supervising Controller 라고 부를 것을 제안
	- 그럼 안드로이드에서 수동적인 뷰는 어떻게 이벤트 처리를 해야 하나?
		- 버튼이 눌렸다 이상의 의미는 감춰져야 함
		- 이벤트 핸들러를 프레젠터에서 구현 하고 그 후에 UI State에 데이터와 함께 람다 형태로 전달

- MVP의 장점
	- Fat Activity/ Fragment를 크게 해결해줌
	- 수동적인 뷰의 이벤트를 적절히 처리할 수 있다
	- 테스트 가능성이 증대함
		- 프레젠터가 context를 갖고 있지 않기 때문
	- 비교적 완만한 학습 곡선을 갖고 있음

- MVP의 단점
	- 잘 못 만들 가능성이 있다.
	- 프레젠터는 뷰의 기능을 기본적으로 메소드 호출을 통해서 호출함
	- 뷰의 기능이 명령형일 때 잘 동작함
		- Compose와 같은 선언형 뷰에는 적용하기 까다로움
	- 기본적으로 뷰가 프레젠터를 참조하고 잇음
		- 잘못된 프레젠터 인터페이스 사용을 완전히 막기 어려움
	- 완전히 수동적인 뷰를 구현하려면 많은 고민이 필요함
	
- MVP의 주의사항
	- 비동기 처리의 결과를 동기적으로 받으면 안된다
		- ANR을 유발할 수 있음. 셰어드 프리퍼런스나 SQLite도 해당
	- 설정 변경에 주의해야 한다
