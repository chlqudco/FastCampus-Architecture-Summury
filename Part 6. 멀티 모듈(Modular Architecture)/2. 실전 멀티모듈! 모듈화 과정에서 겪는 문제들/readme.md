---

- 순환 참조
	- 모듈이 서로를 참조 할 수 없음
	- 그러나 처음 모듈을 분리하면 엄청난 양의 순환 참조를 마주함
	
- 해결책 : 인터페이스 참조
	- 각 모듈을 인터페이스와 그 구현체의 쌍으로 분리. 각 모듈의 구현체는 상대의 인터페이스 모듈을 참조하도록 구성
	- 이점 : 각 모듈은 명시적인 public API를 제공하게 됨

---	

- 거꾸로 된 의존성
	- 잘못된 방향으로 의존성이 만들어진 경우
	- 멀티모듈 상황에서 관계 그래프가 필요 이상으로 복잡해지고 이해하기도 어려워짐

- 해결책 : 의존성 역전의 원칙
	- 구현 클래스의 인터페이스를 만들어 상위 모듈로 옮기는 형태로 의존성의 방향을 반대로 바꾸면 해결됨
	- 바람직한 의존성 방향은 의존성이 흘러가는 직관적인 방향임. 이 방향으로 모델링 해야 함

---

- 멀티모듈을 위해 코틀린은 internal 키워드를 제공
	- public 과 protected의 사이 접근제한자
	- internal은 다른 모듈에서 접근하지 못하게 함

---

- 없어야 할 의존성이 존재함
	- 모듈로 나누기 전까지는 문제의식 없이 쉽게 사용되는 안티패턴
	- 어떤 비즈니스 로직도 특정 액티비티에 의존하면 안되기 때문에 심각한 아키텍쳐상의 문제임

- 해결책 : 새로 발견된 역할을 담당해줄 모듈을 생성
	
---

- god object에 대한 의존성
	
- 해결책 1단계 : god object를 쪼개기
- 해결책 2단계 : 의존성 주입 적용

---

- 너무 많은 유틸리티 클래스들
	- 시스템이 커지면 끝없이 새로 유틸리티 클래스가 생긴다
	- 왜 문제인가?
		- 하나이 유틸 클래스에 접근해도 유틸리티 모듈에 대한 의존성을 갖게 됨, 전체 유틸리티 클래스에 의존
	- 각 유틸리티 클래스들이 갖고 있는 추가 의존성들도 함께 갖게 됨, 필연적으로 순환 참조를 야기
	- 관리 책임의 문제 : 이 많은 클래스들을 누가 관리하나?
	
- 해결책 : 유틸리티 클래스들을 해체
	- 할 수 있는 한 유틸리티 패턴을 지양해야 함
		- 대부분의 유틸리티 메소드들은 일부 호출자에 의해서만 쓰임
	- 큰 유틸리티 클래스나 모듈을 더 잘게 쪼개야 함

- 그럼 어디까지 나눠야 함?
	- 많이 나눠서 후회한 적은 없다!

---

- 정적인 유틸리티 함수들
	- 정적 메소드의 경우 의존성 주입의 대상이 안됨
	- mock을 통한 테스트도 어려움

- 해결책 : 정적 클래스들을 싱글톤으로 전환
	- 의존성 주입을 통해 인스턴스를 얻을 수 있음
	- 호출하는 쪽은 쉽게 mock을 만들어 테스트 할 수 있음

---

- 결론
	- 모듈화에서 생기는 문제들은 보통 큰 스케일의 아키텍처에서 나오는 문제가 불거진 증상
	- 해결책은 각 시스템과 모듈의 책임을 명확히 정의해주는 것
